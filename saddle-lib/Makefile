#
#   Stand-alone program, maybe called from Mathematica
#
MINRESDIR = ../../linear-algebra/minres-qlp
TRLANDIR = ../../linear-algebra/nutrlan
MKLROOT = /usr/local/intel/mkl
PRIMMEDIR = ../../linear-algebra/primme
#
#
#              -Wall -g -O3
CFLAGS = -fPIC -Wall -g -O3 -Wextra -pedantic -std=gnu11 -I$(TRLANDIR)/INC
LFLAGS =  -L$(TRLANDIR) -L/usr/local/lib -lnutrlan -lgfortran
#
#  Optionally, use Jacobi-Davidson library PRIMME
#
#  I abandoned this attempt because putting in user_ortho
#  to enforce the gauge transform constraint appears to be difficult.
ifeq (1, 0)
CFLAGS += -DUSE_PRIMME -I$(PRIMMEDIR)/include
LFLAGS += -L$(PRIMMEDIR)/lib -lprimme
endif
#
#
#    Optionally, use Intel MKL
#
#  This give us a substantial speedup.
ifeq (1, 1)  # Use MKL or not.
#
#  Flags generated by tool:
#  cd /usr/local/intel/mkl/tools; ./mkl_link_tool -interactive
#
#  compiler flags:
CFLAGS += -DUSE_MKL -m64 -I$(MKLROOT)/include
#
#  Linker flags:
#  Looks like dynamic linking doesn't work well if the routine
#  is called by Mathematica.
#  Use static links:
LFLAGS +=  $(MKLROOT)/lib/intel64/libmkl_blas95_lp64.a $(MKLROOT)/lib/intel64/libmkl_lapack95_lp64.a -Wl,--start-group $(MKLROOT)/lib/intel64/libmkl_intel_lp64.a $(MKLROOT)/lib/intel64/libmkl_gnu_thread.a $(MKLROOT)/lib/intel64/libmkl_core.a -Wl,--end-group -lgomp -lpthread -lm -ldl
#  Dynamic:
#LFLAGS += -L$(MKLROOT)/lib/intel64 -lmkl_blas95_lp64 -lmkl_lapack95_lp64 -Wl,--no-as-needed -lmkl_rt -lpthread -ldl
#LFLAGS += -L$(MKLROOT)/lib/intel64  -lmkl_blas95_lp64 -lmkl_lapack95_lp64 -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -lgomp -lpthread -ldl
else
LFLAGS += -llapack -lblas
endif
#
#   Use block-sparse coordinate format for matrices
#
ifeq (1, 0)
CFLAGS += -DUSE_BLOCK
endif

MINRESOBJS = $(MINRESDIR)/minresqlpModule.o $(MINRESDIR)/minresqlpDataModule.o  $(MINRESDIR)/minresqlpBlasModule.o
SHIFTOBJS = shifts.o dynamic.o eigensystem.o cutoff.o linear.o mmio.o sort.o

shifts: $(SHIFTOBJS)
	$(CC) $(CFLAGS) -o shifts $(SHIFTOBJS) $(MINRESOBJS) $(LFLAGS) -lm -lcjson

%.o: %.c shifts.h mmio.h
	$(CC) -c -o $@ $< $(CFLAGS)

clean:
	rm shifts *.o
